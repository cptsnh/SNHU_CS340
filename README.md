# SNHU_CS340 Client-Server Development
## How do you write programs that are maintainable, readable, and adaptable? 
All software projects inevitably face software entropy. Most applications are inevitably updated, changed, or maintained in some way. Problems arise when programs are not adaptable, are not readable, or when we make modifications for short term gain without considering the long-term effect of change with regards to maintainability (technical debt). So the idea is to write programs that are maintainable, readable, and adaptable from the beginning to help offset software entropy.  
For this project, and as a general paradigm we can separate core functions of application so that they are easily identifiable, logically separated, and follow a standard practice. In this case, we separated the four core functions – create, read, update, and delete (CRUD) – and implemented them accordingly. This helps in the long-term because a change one function may not impact the others. Likewise, if we have problem deleting records, for example, we know exactly where to look for the problem (in the delete implementation).  
At an ever higher-level, consider the widgets that are used in the project: the mapping API, and the chart API. These are separate components that we interface. We do not need to re-invent the wheel by writing our own functionality to do the same thing. Furthermore, we have a certain amount of trust that the API’s are already tested. So, from the perspective of testing, we only need to test the code that we write. Again, we had to write our own functionality that these APIs already provide, then there would be considerable amount of testing involved in our development process.  
As a final note, we also developed our own CRUD library file. This library file acted as own interface to the CRUD functionality. There are several benefits of this: first, we can re-use this library file on any future projects that need similar functionality. Second, since the library file is already tested, we trust that it will work on other projects as well. This reduces development time in the future two-fold: we don’t need to re-invent the wheel and we don’t need to re-test for the same functionality that is already proven successful. 

## How do you approach a problem as a computer scientist? 
We have studied various software development models throughout the courses at SNHU. They all have their advantages and disadvantages, and are used based on the needs of the organization and how they feel best to meet their needs. I used an Agile-based approach for completing this project. I feel this approach worked very well because I could work on the technologies and functionalities incrementally. Furthermore, I could test functionality in each iteration before moving on to the next one.  
I wanted to prove my concept would work, but I also wanted to focus on quality during each iteration. For example, the first thing I worked on was the database functionality. I worked on the database queries directly using Mongo Shell before implementing them in the CRUD library. After I got them working, I then implemented the queries in CRUD library.  
Another example is when working on the dashboard, I initially focused on the datatable and getting all the functionality working correctly on that piece before working on the map API and the chart API. The datatable may seem simple, but it took a lot of time to figure how to get a single row highlighted to work correctly when I added in pagination. I want to get that piece working correctly before moving forward, because I didn’t want to interfere with new functionality of the map and chart later. I followed this same principle for the map API. I worked on the map API in the next iteration and got it working bug free before working on the chart API.


## What do computer scientists do, and why does it matter?
Computer science is a term with a very broad-scope. It encompasses almost every facet of software development – ranging from testing, development, and designing software systems. Computer scientists are important for many reasons. Sufficed to say, they are important because almost everything we do in life today involves using software applications. Computer scientists solve problems by developing software that interacts with systems and people to accomplish goals.
This project has several key learning opportunities. Something I found most interesting about it is how quick and easily a developer can get a highly functional dashboard running for a customer. This is in large part thanks to the underlying technologies that enable functional components to work together. For example, the PyMongo adapter enables Python to interface with MongoDB. Another example is the Dash framework that enables building a functional user-interface application designed for data analysis and business intelligence using interfaces with Python.  
One reason that it helps a company like Grazioso is because they can easily find and analyze data. For example, they can graphically visualize information using the charts (or graphs), as well as get geographic information that is displayed on a street mapping API. This is a huge time savings, because otherwise Grazioso would have to interface with multiple systems individually. Imagine if you had to manually type in every address you want to visit into google maps every time you want to go somewhere. It would be impracticable and frustrating. Furthermore, imagine if they had to manually search multiple databases individually. There would be human error, conflicting information, out-of-date information, and overall Grazioso would spend more time determining what information is valuable or not then they would actually analyzing information they are interested in.  






